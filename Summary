总的来说是不太成功的一个代码编写及实现，好在功能总算做出来了

存在的缺陷：
	代码框架有点乱
	有些字符串分配的不合理
	没有离线消息，离线消息的部分要做好的话要对线程理解较深，目前代码功底还达不到那个要求，
	如果还是在当前单进程设计做的话，可能多个人同时登录上来会明显感觉到延迟
	服务器设计有点不合理，由于是单进程多路复用的方式，所以并发性能并不好，主要缺陷点如下：
	占用较多时间的部分可能会影响到服务器响应的速度，这样当用户一多，单进程多路复用的服务器可能会应付不过来
		占用较多时间的部分
			如果设计离线消息，发送离线消息占用时间会比较长
			注册、登录如果用户较多可能会花比较多的时间
			命令（help、onlinenum、onlinename）可能在某些情况下占用时间较多而影响其他部分的响应
			群组消息：由于是给所有的在线用户都发送，所以可能会花费较多时间，这样服务器在这个过程中就不能响应其他事件了
	后面用测试程序测试了一下1000个连接的反应情况，用的阿里云的服务器1M的带宽，处理1000个连接是没问题的，
	而且几乎感觉不到延迟。而1000个也是这个程序的极限了。其实个1020是最极限了。
	最大的短板可能就是不能容忍太大的数据块传输，不过聊天都是一些小数据，没多大影响
	暂时只考虑小端主机到小端主机的传输
	没有做防止恶意连接、恶意发消息的动作
	没有做提醒哪个用户下线的动作
	由于是终端运行，存在几乎以下不可解决的问题：
		如果终端不是UTF-8发送和显示都乱码
		输入和输出会混和在一起

代码细节：
	要注意包裹函数的实现
	要注意代码模块化：高内聚、低耦合的原则
	注意printf的打印技巧
	fopen类的函数是有缓冲区，open、read的函数都是不带缓冲区的
	poll函数没法忽略值为-1元素，select会忽略值为-1的元素
	select函数检测到有数据时，会稍等一会儿才返回，这样的结果是会累积到好几个才返回
	open函数的O_CREATE必须要第3个参数存在才能起作用
	printf输出缓冲区，linux下是行缓冲的
	输入缓冲区问题，需要处理上一次遗留在缓冲区中的内容
	write函数返回Bad file descriptor原因之一是没有写权限
	inet_ntoa不加对头文件的话，gcc编译器会把它当成整数，会返回一个下面的类似的警告，误导程序员，我曾经被这个坑了3小时，头发都被抓烂
	（因为找错关键点，一直不认为是inet_ntoa的问题）
	chatfunc.c:229:17: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
		         printf("%s connected\n", inet_ntoa(cli_record[i].cliaddr.sin_addr));
		         ^
	可以下载glibc源码，会看到很多好用的函数，然后可以根据自己的需要自定义出来
